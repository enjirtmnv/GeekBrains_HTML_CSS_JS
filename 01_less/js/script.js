
//Синтаксис добавления обработчика:
//element.addEventListener(event, handler[, options]);

//event - Имя события, например "click".
// handler - Ссылка на функцию-обработчик.
// options - Дополнительный объект со свойствами:
//
// 1)once: если true, тогда обработчик будет автоматически удалён после выполнения.

// 2)capture: фаза, на которой должен сработать обработчик, options может быть false/true,
// это тоже самое, что {capture: false/true}.
//  Если аргумент false (по умолчанию), то событие будет поймано при всплытии.
// Если аргумент true, то событие будет перехвачено при погружении.

// 3)passive: если true, то указывает, что обработчик никогда не вызовет preventDefault()


//Когда на элементе происходит событие, обработчики сначала срабатывают на нём,
//потом на его родителе, затем выше и так далее, вверх по цепочке предков.
//Этот процесс называется «всплытием», потому что события «всплывают» от внутреннего элемента вверх через родителей
//подобно тому, как всплывает пузырёк воздуха в воде.

//Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target.
//Отличия от this (=event.currentTarget):
// event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.
// this – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.

//Существует ещё одна фаза из жизненного цикла события – «погружение» (иногда её называют «перехват»).
// Она очень редко используется в реальном коде, однако тоже может быть полезной.

// Стандарт DOM Events описывает 3 фазы прохода события:
//
// Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
// Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
// Фаза всплытия (bubbling stage) – событие начинает всплывать.




//Создание события прокрутки

//с помощью JavaScript мы определяем момент прокрутки пользователем веб-страницы.
// Всякий раз, когда вы прокручиваете страницу, ваш браузер запускает событие прокрутки.
// Вот самый простой способ проверить это:

//window.addEventListener('scroll', myScrolling, false);
// function myScrolling(e) {}

//Каждый раз, когда вы скроллите в окне браузера, вызывается обработчик событий myScrolling.
// Выглядит довольно просто, не так ли? Но существует небольшая проблема с данным подходом.
// Данное событие вызывается при очень большой частоте,
// поэтому вам нужно не допустить конфликта с DOM (объектной моделью документа).
// Вы можете использовать setTimeOut или setInterval,
// чтобы определить задержку реакции браузера на обработку того или иного события,
// но лучше привязать данные параметры к частоте обновления кадров страницы.
// Это может быть осуществлено с помощью метода requestAnimationFrame.
//
// window.requestAnimationFrame указывает браузеру на то, что вы хотите произвести анимацию,
// и просит его запланировать перерисовку на следующем кадре анимации.
// В качестве параметра метод получает функцию, которая будет вызвана перед перерисовкой.
// Синтаксис: window.requestAnimationFrame(callback);
// callback - функция, которая будет вызвана, когда придёт время обновить вашу анимацию на следующей перерисовке.
// Советуем взглянуть на следующий фрагмент:

let isScrolling = false;

window.addEventListener('scroll', myScrolling, false);

function myScrolling(e) {
    if (isScrolling == false){
        window.requestAnimationFrame(function () {  //Избавляемся от подергиваний во время анимации
            footerScrolling(e);
            isScrolling = false;
        });
    }
    isScrolling =true;
}

//Как только страница начинает прокручиваться, вызывается обработчик событий footerScrolling.
// Разница лишь в том, что наш обработчик событий не будет вызван раньше, чем метод requestAnimationFrame.
// Это значит, что текущий обработчик событий будет вызван около 60 раз в секунду,
// что является допустимым значением при работе с DOM структурами различного рода.


//Определение видимых элементов

//Нужно ыяснить, какие из элементов на текущей веб-странице можно считать видимыми при скроллинге.
// Чтобы это осуществить, используем метод getBoundingClientRect.
// Этот метод возвращает некий прямоугольник, который ограничивает ту самую видимую область,
// со значениями относительно верха, низа страницы, левого и правого направлений,
// а также относительно левого верхнего угла браузера и его основных свойств (ширины и высоты окна).
// Другими вашими помощниками будут выступать свойства window.innerHeight window.innerWidth,
// которые возвращают высоту и ширину окна браузера соответственно.
//

//В тот момент, когда наши элементы, расположенные на веб-странице, получают активный статус,
// параметры стилей .footer.active и .footerText.active применяются к ним.
// Это ключевой момент, когда видимые элементы отличаются от невидимых (которым не присваивается никакое значение).


document.addEventListener("DOMContentLoaded", footerScrolling, false);

let footerText = document.querySelector('.footerText');
let footer = document.querySelector('.footer');

function footerScrolling(e) {
    if (fullVisible(footerText)) {
        footerText.classList.add('active');
        footer.classList.add('colorOne');
    } else {
        footerText.classList.remove('active');
        footer.classList.remove('colorOne');
    }
}

function fullVisible(el) {
    elementBorder = el.getBoundingClientRect();     //Определение полностью видимых элементов

    let top = elementBorder.top;
    let bottom = elementBorder.bottom;

    return ((top >= 0) && (bottom <= window.innerHeight));
}
// Если элемент определился, как полностью видимый, то функция isFullyVisible вернет значение true,
// если же данный элемент оказался частично видимым для пользователя, то наша функция вернет значение false.


function partVisible(el) {
    let elementBorder = el.getBoundingClientRect();   //Определение частично видимых элементов

    let top = elementBorder.top;
    let bottom = elementBorder.bottom;
    let height = elementBorder.height;

    return ((top + height >= 0) && (height + window.innerHeight >= bottom));
}
//В качестве аргумента функции нам необходимо передать элемент.
// Если элемент частично видимый, функция вернет true. Иначе, функция вернет false.





